Creates the S3 bucket

Enforces bucket encryption (SSE-S3 AES256) (simple + “AWS-owned” vibe)

Creates the IAM role + S3 access policy

Optional Lambda invoke policy

Creates Firehose with stream encryption enabled using AWS-owned key:
server_side_encryption { key_type = "AWS_OWNED_CMK" }

Uses your dynamic Lambda processor pattern

modules/aws-kinesis-firehose/main.tf
#####################################################################
############################################
# Data
############################################
data "aws_partition" "current" {}
data "aws_caller_identity" "current" {}

############################################
# Variables
############################################
variable "delivery_stream_name" {
  type        = string
  description = "Firehose delivery stream name"
}

variable "buffering_size" {
  type        = number
  default     = 5
}

variable "buffering_interval" {
  type        = number
  default     = 300
}

variable "enable_firehose_encryption" {
  type        = bool
  default     = true
  description = "Enable Firehose stream encryption (DeliveryStreamEncryptionConfiguration)"
}

variable "enable_lambda_processor" {
  type        = bool
  default     = false
}

variable "lambda_function_arn" {
  type        = string
  default     = null
}

variable "lambda_parameter_name" {
  type        = string
  default     = "LambdaArn"
}

# S3 bucket naming control
variable "bucket_name" {
  type        = string
  description = "S3 bucket name (must be globally unique). If null, module will generate a name."
  default     = null
}

############################################
# Locals
############################################
locals {
  account_id = data.aws_caller_identity.current.account_id

  effective_bucket_name = coalesce(
    var.bucket_name,
    "firehose-logs-${local.account_id}-${var.delivery_stream_name}"
  )
}

############################################
# S3 bucket for Firehose destination
############################################
resource "aws_s3_bucket" "firehose_logs" {
  bucket = local.effective_bucket_name
}

# Bucket encryption (AWS-owned style: SSE-S3)
resource "aws_s3_bucket_server_side_encryption_configuration" "firehose_logs" {
  bucket = aws_s3_bucket.firehose_logs.id

  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}

############################################
# IAM role for Firehose
############################################
resource "aws_iam_role" "firehose" {
  name = "${var.delivery_stream_name}-firehose-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Effect    = "Allow"
      Action    = "sts:AssumeRole"
      Principal = { Service = "firehose.amazonaws.com" }
    }]
  })
}

# Allow Firehose to write to the S3 bucket
resource "aws_iam_role_policy" "firehose_s3" {
  name = "${var.delivery_stream_name}-s3-policy"
  role = aws_iam_role.firehose.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Effect = "Allow"
      Action = [
        "s3:AbortMultipartUpload",
        "s3:GetBucketLocation",
        "s3:GetObject",
        "s3:ListBucket",
        "s3:ListBucketMultipartUploads",
        "s3:PutObject"
      ]
      Resource = [
        aws_s3_bucket.firehose_logs.arn,
        "${aws_s3_bucket.firehose_logs.arn}/*"
      ]
    }]
  })
}

# Optional: allow Firehose to invoke Lambda if processor enabled
resource "aws_iam_role_policy" "firehose_lambda" {
  count = var.enable_lambda_processor ? 1 : 0

  name = "${var.delivery_stream_name}-lambda-policy"
  role = aws_iam_role.firehose.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Effect = "Allow"
      Action = [
        "lambda:InvokeFunction",
        "lambda:GetFunctionConfiguration"
      ]
      Resource = var.lambda_function_arn
    }]
  })
}

############################################
# Firehose Delivery Stream
############################################
resource "aws_kinesis_firehose_delivery_stream" "firehose_stream" {
  name        = var.delivery_stream_name
  destination = "extended_s3"

  # ✅ COMPLIANCE: enables DeliveryStreamEncryptionConfiguration (AWS owned key)
  dynamic "server_side_encryption" {
    for_each = var.enable_firehose_encryption ? [1] : []
    content {
      enabled  = true
      key_type = "AWS_OWNED_CMK"
    }
  }

  extended_s3_configuration {
    role_arn           = aws_iam_role.firehose.arn
    bucket_arn         = aws_s3_bucket.firehose_logs.arn
    buffering_size     = var.buffering_size
    buffering_interval = var.buffering_interval

    # (For AWS-owned key approach, we do NOT set kms_key_arn here)
    # kms_key_arn = ...

    dynamic "processing_configuration" {
      for_each = var.enable_lambda_processor ? [1] : []
      content {
        enabled = true

        processors {
          type = "Lambda"

          parameters {
            parameter_name  = var.lambda_parameter_name
            parameter_value = var.lambda_function_arn
          }
        }
      }
    }
  }

  lifecycle {
    precondition {
      condition     = var.enable_lambda_processor ? (var.lambda_function_arn != null && length(trim(var.lambda_function_arn)) > 0) : true
      error_message = "enable_lambda_processor is true but lambda_function_arn is not set."
    }
  }
}
#################################################

######################################################################
How to call this module (root)

module "firehose_logs" {
  source = "./modules/aws-kinesis-firehose"

  delivery_stream_name = "logs-firehose-test"
  buffering_size       = 5
  buffering_interval   = 300

  enable_firehose_encryption = true

  enable_lambda_processor = false

  # optional override if you want a specific bucket name:
  # bucket_name = "my-unique-firehose-logs-bucket-12345"
}



